<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML„Éü„Éã„Ç≤„Éº„É†ÈõÜ - Bounce Ball & Snake</title>
    <style>
        body { 
            margin: 0; 
            background: linear-gradient(135deg, #000, #111); 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            min-height: 100vh;
            touch-action: none;
            font-family: 'Arial Black', sans-serif;
            color: white;
            text-shadow: 0 0 10px #0f0;
        }
        canvas { 
            border: 4px solid #0f0; 
            background: #000;
            box-shadow: 0 0 30px #0f0;
            touch-action: none;
            max-width: 95vw;
            max-height: 70vh;
        }
        .menu { 
            text-align: center; 
        }
        .menu h1 { 
            font-size: 48px; 
            margin: 20px 0; 
            background: linear-gradient(45deg, #fff, #0f0); 
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent; 
        }
        .menu button { 
            display: block; 
            margin: 20px auto; 
            padding: 20px 40px; 
            font-size: 28px; 
            font-weight: bold; 
            background: linear-gradient(45deg, #0f0, #0a0); 
            color: #000; 
            border: none; 
            border-radius: 20px; 
            cursor: pointer; 
            box-shadow: 0 10px 20px rgba(0,255,0,0.3); 
            transition: all 0.3s; 
            min-width: 300px;
        }
        .menu button:hover, .menu button:active { 
            transform: scale(1.05); 
            box-shadow: 0 15px 30px rgba(0,255,0,0.5); 
        }
        #backBtn, #restartBtn { 
            position: absolute; 
            top: 20px; 
            padding: 12px 24px; 
            font-size: 18px; 
            background: rgba(0,255,0,0.8); 
            color: #000; 
            border: none; 
            border-radius: 10px; 
            cursor: pointer; 
            z-index: 20;
        }
        #backBtn { left: 20px; }
        #restartBtn { right: 20px; display: none; }
        #backBtn:hover, #restartBtn:hover { background: #0f0; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <button id="backBtn" style="display:none;">‚Üê „É°„Éã„É•„Éº</button>
    <button id="restartBtn">„É™„Çπ„Çø„Éº„Éà</button>

    <div id="menu" class="menu">
        <h1>üéÆ „Éü„Éã„Ç≤„Éº„É†ÈõÜ</h1>
        <button onclick="startGame('bounce')">üèÄ Bounce Ball</button>
        <button onclick="startGame('snake')">üêç Snake</button>
        <p style="font-size:18px; margin-top:40px;">PC/„Çπ„Éû„Éõ/iPad ÂØæÂøúÔºÅ</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const menu = document.getElementById('menu');
        const backBtn = document.getElementById('backBtn');
        const restartBtn = document.getElementById('restartBtn');

        let currentGame = 'menu';
        let gameRunning = true;

        // ÂÖ±ÈÄö„É™„Çµ„Ç§„Ç∫
        function resizeCanvas() {
            const aspect = 800 / 600;
            const maxW = window.innerWidth * 0.95;
            const maxH = window.innerHeight * 0.75;
            if (maxW / aspect < maxH) {
                canvas.width = maxW;
                canvas.height = maxW / aspect;
            } else {
                canvas.height = maxH;
                canvas.width = maxH * aspect;
            }
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // „É°„Éã„É•„ÉºÈñãÂßã
        function startGame(gameType) {
            currentGame = gameType;
            menu.style.display = 'none';
            backBtn.style.display = 'block';
            restartBtn.style.display = 'none';
            initGame();
            gameLoop();
        }

        // „É°„Éã„É•„Éº„Å´Êàª„Çã
        backBtn.onclick = () => {
            currentGame = 'menu';
            menu.style.display = 'block';
            backBtn.style.display = 'none';
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        };

        // === BOUNCE BALL ===
        let bounce = {
            ball: { x: 400, y: 500, radius: 12, dx: 5, dy: -5, speed: 5 },
            paddle: { width: 120, height: 18, x: 340, y: 570, speed: 10 },
            score: 0
        };

        function initBounce() {
            bounce.score = 0;
            bounce.ball.x = canvas.width / 2;
            bounce.ball.y = canvas.height - 100;
            bounce.ball.dx = bounce.ball.speed * (Math.random() > 0.5 ? 1 : -1);
            bounce.ball.dy = -bounce.ball.speed;
            bounce.paddle.x = canvas.width / 2 - bounce.paddle.width / 2;
            bounce.paddle.y = canvas.height - 35;
            gameRunning = true;
        }

        function updatePaddle(clientX = null) {
            if (clientX !== null) {
                const rect = canvas.getBoundingClientRect();
                bounce.paddle.x = clientX - rect.left - bounce.paddle.width / 2;
            } else {
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) bounce.paddle.x -= bounce.paddle.speed;
                if (keys['ArrowRight'] || keys['d'] || keys['D']) bounce.paddle.x += bounce.paddle.speed;
            }
            bounce.paddle.x = Math.max(0, Math.min(canvas.width - bounce.paddle.width, bounce.paddle.x));
        }

        canvas.addEventListener('mousemove', e => currentGame === 'bounce' && updatePaddle(e.clientX));
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (currentGame === 'bounce') updatePaddle(e.touches[0].clientX);
            if (currentGame === 'snake') handleSwipe(e.touches[0]);
        }, { passive: false });

        const keys = {};
        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);

        function drawBounce() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // „Éú„Éº„É´
            ctx.beginPath();
            ctx.arc(bounce.ball.x, bounce.ball.y, bounce.ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 20; ctx.shadowColor = '#fff';
            ctx.fill();
            ctx.shadowBlur = 0;
            // „Éë„Éâ„É´
            ctx.fillStyle = '#0f0';
            ctx.shadowBlur = 20; ctx.shadowColor = '#0f0';
            ctx.fillRect(bounce.paddle.x, bounce.paddle.y, bounce.paddle.width, bounce.paddle.height);
            ctx.shadowBlur = 0;
            // „Çπ„Ç≥„Ç¢
            ctx.font = 'bold 40px Arial';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'left';
            ctx.fillText(`„Çπ„Ç≥„Ç¢: ${bounce.score}`, 30, 60);
        }

        function updateBounce() {
            bounce.ball.x += bounce.ball.dx;
            bounce.ball.y += bounce.ball.dy;

            // Â£Å
            if (bounce.ball.x + bounce.ball.dx > canvas.width - bounce.ball.radius || bounce.ball.x + bounce.ball.dx < bounce.ball.radius) {
                bounce.ball.dx = -bounce.ball.dx; bounce.score++;
            }
            if (bounce.ball.y + bounce.ball.dy < bounce.ball.radius) {
                bounce.ball.dy = -bounce.ball.dy; bounce.score++;
            }
            // „Éë„Éâ„É´
            if (bounce.ball.y + bounce.ball.dy + bounce.ball.radius > bounce.paddle.y &&
                bounce.ball.x > bounce.paddle.x && bounce.ball.x < bounce.paddle.x + bounce.paddle.width) {
                bounce.ball.dy = -Math.abs(bounce.ball.dy) * 1.03;
                const hit = (bounce.ball.x - (bounce.paddle.x + bounce.paddle.width/2)) / (bounce.paddle.width/2);
                bounce.ball.dx = hit * 8;
                bounce.score += 2;
            }
            // „Ç™„Éº„Éê„Éº
            if (bounce.ball.y > canvas.height) gameRunning = false;
        }

        // === SNAKE ===
        const GRID_SIZE = 20;
        let snake = {
            body: [{x: 10, y: 10}],
            dir: {x: 1, y: 0},
            food: {x: 15, y: 10},
            score: 0
        };

        function initSnake() {
            snake.body = [{x: 10, y: 10}];
            snake.dir = {x: 1, y: 0};
            snake.food = generateFood();
            snake.score = 0;
            gameRunning = true;
        }

        function generateFood() {
            let food;
            do {
                food = {
                    x: Math.floor(Math.random() * (canvas.width / GRID_SIZE)),
                    y: Math.floor(Math.random() * (canvas.height / GRID_SIZE - 5)) + 1 // ‰∏ãÈÉ®ÈÅø„Åë
                };
            } while (snake.body.some(segment => segment.x === food.x && segment.y === food.y));
            return food;
        }

        function drawSnake() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // „Éò„Éì
            ctx.fillStyle = '#0f0';
            snake.body.forEach((segment, i) => {
                ctx.shadowBlur = i === 0 ? 25 : 10;
                ctx.shadowColor = '#0f0';
                ctx.fillRect(segment.x * GRID_SIZE, segment.y * GRID_SIZE, GRID_SIZE - 2, GRID_SIZE - 2);
            });
            ctx.shadowBlur = 0;
            // È†≠
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 30; ctx.shadowColor = '#fff';
            ctx.fillRect(snake.body[0].x * GRID_SIZE + 2, snake.body[0].y * GRID_SIZE + 2, GRID_SIZE - 6, GRID_SIZE - 6);
            ctx.shadowBlur = 0;
            // È£ü„ÅπÁâ©
            ctx.fillStyle = '#f00';
            ctx.shadowBlur = 20; ctx.shadowColor = '#f00';
            ctx.fillRect(snake.food.x * GRID_SIZE + 4, snake.food.y * GRID_SIZE + 4, GRID_SIZE - 10, GRID_SIZE - 10);
            ctx.shadowBlur = 0;
            // „Çπ„Ç≥„Ç¢
            ctx.font = 'bold 40px Arial';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'left';
            ctx.fillText(`„Çπ„Ç≥„Ç¢: ${snake.score}`, 30, 60);
        }

        let lastDir = {x:1, y:0};
        const dirs = [
            {x:1, y:0}, {x:0, y:1}, {x:-1, y:0}, {x:0, y:-1}
        ];

        function changeDir(newDir) {
            if ((newDir.x === -lastDir.x && newDir.y === 0) || (newDir.y === -lastDir.y && newDir.x === 0)) return;
            snake.dir = newDir;
            lastDir = newDir;
        }

        // „Ç≠„ÉºÂÖ•Âäõ SnakeÁî®
        window.addEventListener('keydown', e => {
            if (currentGame !== 'snake') return;
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') changeDir({x:0, y:-1});
            if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') changeDir({x:0, y:1});
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') changeDir({x:-1, y:0});
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') changeDir({x:1, y:0});
        });

        // „Çø„ÉÉ„ÉÅ„Çπ„ÉØ„Ç§„ÉóÊ§úÂá∫
        let touchStartX, touchStartY;
        canvas.addEventListener('touchstart', e => {
            if (currentGame === 'snake') {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }
        });
        function handleSwipe(touch) {
            if (!touchStartX || !touchStartY) return;
            const dx = touch.clientX - touchStartX;
            const dy = touch.clientY - touchStartY;
            if (Math.abs(dx) > Math.abs(dy)) {
                changeDir(dx > 0 ? {x:1,y:0} : {x:-1,y:0});
            } else {
                changeDir(dy > 0 ? {x:0,y:1} : {x:0,y:-1});
            }
            touchStartX = touchStartY = null;
        }

        function updateSnake() {
            const head = {x: snake.body[0].x + snake.dir.x, y: snake.body[0].y + snake.dir.y};

            // Â£Å/Ëá™ÂàÜË°ùÁ™Å
            if (head.x < 0 || head.x >= canvas.width / GRID_SIZE || head.y < 0 || head.y >= canvas.height / GRID_SIZE ||
                snake.body.some(s => s.x === head.x && s.y === head.y)) {
                gameRunning = false;
                return;
            }

            snake.body.unshift(head);

            // È£ü„ÅπÁâ©
            if (head.x === snake.food.x && head.y === snake.food.y) {
                snake.score += 10;
                snake.food = generateFood();
            } else {
                snake.body.pop();
            }
        }

        // === ÂÖ±ÈÄö ===
        function initGame() {
            if (currentGame === 'bounce') initBounce();
            else if (currentGame === 'snake') initSnake();
        }

        restartBtn.onclick = () => {
            initGame();
            restartBtn.style.display = 'none';
        };

        function gameLoop() {
            if (currentGame === 'bounce') {
                updatePaddle();
                if (gameRunning) {
                    updateBounce();
                } else {
                    drawGameOver('bounce');
                    restartBtn.style.display = 'block';
                }
            } else if (currentGame === 'snake') {
                if (gameRunning) {
                    updateSnake();
                } else {
                    drawGameOver('snake');
                    restartBtn.style.display = 'block';
                }
            }
            if (currentGame === 'bounce') drawBounce();
            else if (currentGame === 'snake') drawSnake();
            requestAnimationFrame(gameLoop);
        }

        function drawGameOver(game) {
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.font = 'bold 60px Arial';
            ctx.fillText('„Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºÔºÅ', canvas.width/2, canvas.height/2);
            ctx.font = 'bold 40px Arial';
            const finalScore = game === 'bounce' ? bounce.score : snake.score;
            ctx.fillText(`ÊúÄÁµÇ„Çπ„Ç≥„Ç¢: ${finalScore}`, canvas.width/2, canvas.height/2 + 60);
        }

        // ÈñãÂßã
        resizeCanvas();
    </script>
</body>
</html>
