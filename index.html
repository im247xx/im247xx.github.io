<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ミニゲーム集</title>
    <style>
        body { 
            margin: 0; 
            background: #000; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            min-height: 100vh;
            touch-action: none;
            font-family: Arial, sans-serif;
            color: white;
        }
        canvas { 
            border: 4px solid #0f0; 
            background: #111;
            max-width: 95vw;
            max-height: 70vh;
        }
        .menu { text-align: center; margin-top: 50px; }
        .menu h1 { font-size: 40px; color: #0f0; margin-bottom: 40px; }
        .menu button { 
            margin: 20px; padding: 20px 50px; 
            font-size: 28px; background: #0f0; color: black;
            border: none; border-radius: 20px; cursor: pointer;
        }
        #backBtn, #restartBtn { 
            position: absolute; top: 20px; padding: 12px 24px; 
            font-size: 18px; background: #0f0; color: black; 
            border: none; border-radius: 10px; cursor: pointer; z-index: 10;
        }
        #backBtn { left: 20px; display: none; }
        #restartBtn { right: 20px; display: none; }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border: 2px solid #0f0;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 15;
        }
        #controls label { font-size: 24px; color: #0f0; }
        #speedSlider { width: 85%; height: 20px; border-radius: 15px; background: #333; }
        #speedSlider::-webkit-slider-thumb {
            width: 40px; height: 40px; border-radius: 50%; background: #0f0; box-shadow: 0 0 20px #0f0;
        }
        #speedValue { font-size: 28px; color: #0f0; margin-top: 10px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <button id="backBtn">← メニュー</button>
    <button id="restartBtn">もう一度</button>

    <div id="controls">
        <label>速さ</label>
        <input type="range" id="speedSlider" min="1" max="10" value="5">
        <div id="speedValue">普通（5）</div>
    </div>

    <div id="menu" class="menu">
        <h1>ミニゲーム集</h1>
        <button onclick="startGame('bounce')">ボールはじくゲーム</button>
        <button onclick="startGame('snake')">ヘビゲーム</button>
    </div>

    <script>
        // 1回目ここまで
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const menu = document.getElementById('menu');
        const backBtn = document.getElementById('backBtn');
        const restartBtn = document.getElementById('restartBtn');
        const controls = document.getElementById('controls');
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');

        let currentGame = 'menu';
        let gameRunning = true;
        let speedLevel = 5;

        speedSlider.addEventListener('input', () => {
            speedLevel = parseInt(speedSlider.value);
            const names = ['超遅', '遅め', '少し遅', 'やや遅', '普通', 'やや速', '少し速', '速め', '高速', '超速'];
            speedValue.textContent = names[speedLevel - 1] + `（${speedLevel}）`;
        });

        function resizeCanvas() {
            const maxW = window.innerWidth * 0.95;
            const maxH = window.innerHeight * 0.7;
            canvas.width = maxW;
            canvas.height = maxW * 0.75;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function startGame(gameType) {
            currentGame = gameType;
            menu.style.display = 'none';
            backBtn.style.display = 'block';
            controls.style.display = 'block';
            restartBtn.style.display = 'none';
            speedSlider.value = 5;
            speedLevel = 5;
            speedValue.textContent = '普通（5）';
            initGame();
            gameLoop();
        }

        backBtn.onclick = () => {
            currentGame = 'menu';
            menu.style.display = 'block';
            backBtn.style.display = 'none';
            controls.style.display = 'none';
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        };

        // ここまでが1回目！ 保存したら「2回目ください」って言ってね！
                // 2回目！ これを1回目の<script>の最後に貼り付けてください！
        // 1回目の終わりに「// ここまでが1回目！」ってあったところのすぐ下にこのコードを全部貼る

        const keys = {};
        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);

        canvas.addEventListener('mousemove', e => {
            if (currentGame === 'bounce') updatePaddle(e.clientX);
        });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (currentGame === 'bounce') updatePaddle(e.touches[0].clientX);
        }, { passive: false });

        // === BOUNCE BALL ===
        let bounce = {
            ball: { x: 0, y: 0, radius: 12, dx: 5, dy: -5 },
            paddle: { width: 120, height: 18, x: 0, y: 0 },
            score: 0
        };

        function initBounce() {
            bounce.score = 0;
            bounce.ball.x = canvas.width / 2;
            bounce.ball.y = canvas.height - 100;
            bounce.ball.dx = 5 * (Math.random() > 0.5 ? 1 : -1);
            bounce.ball.dy = -5;
            bounce.paddle.x = canvas.width / 2 - 60;
            bounce.paddle.y = canvas.height - 40;
            gameRunning = true;
        }

        function updatePaddle(clientX = null) {
            if (clientX !== null) {
                const rect = canvas.getBoundingClientRect();
                bounce.paddle.x = clientX - rect.left - bounce.paddle.width / 2;
            } else {
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) bounce.paddle.x -= 12;
                if (keys['ArrowRight'] || keys['d'] || keys['D']) bounce.paddle.x += 12;
            }
            bounce.paddle.x = Math.max(0, Math.min(canvas.width - bounce.paddle.width, bounce.paddle.x));
        }

        function drawBounce() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // ボール
            ctx.beginPath();
            ctx.arc(bounce.ball.x, bounce.ball.y, bounce.ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            // パドル
            ctx.fillStyle = '#0f0';
            ctx.fillRect(bounce.paddle.x, bounce.paddle.y, bounce.paddle.width, bounce.paddle.height);
            // スコア
            ctx.font = 'bold 40px Arial';
            ctx.fillStyle = '#fff';
            ctx.fillText(`スコア: ${bounce.score}`, 30, 60);
        }

        function updateBounce() {
            const mult = speedLevel / 5;
            bounce.ball.x += bounce.ball.dx * mult;
            bounce.ball.y += bounce.ball.dy * mult;

            if (bounce.ball.x < bounce.ball.radius || bounce.ball.x > canvas.width - bounce.ball.radius) {
                bounce.ball.dx = -bounce.ball.dx;
                bounce.score++;
            }
            if (bounce.ball.y < bounce.ball.radius) {
                bounce.ball.dy = -bounce.ball.dy;
                bounce.score++;
            }
            if (bounce.ball.y + bounce.ball.radius > bounce.paddle.y &&
                bounce.ball.x > bounce.paddle.x && bounce.ball.x < bounce.paddle.x + bounce.paddle.width) {
                bounce.ball.dy = -Math.abs(bounce.ball.dy) * 1.03;
                const hit = (bounce.ball.x - (bounce.paddle.x + bounce.paddle.width / 2)) / (bounce.paddle.width / 2);
                bounce.ball.dx = hit * 8;
                bounce.score += 2;
            }
            if (bounce.ball.y > canvas.height) gameRunning = false;
        }

        // === SNAKE ===
        const GRID = 20;
        let snake = { body: [], dir: {x:1,y:0}, food: {}, score: 0 };
        let lastTime = 0;
        const BASE = 200;

        function initSnake() {
            snake.body = [{x:10, y:10}];
            snake.dir = {x:1, y:0};
            snake.food = {x: Math.floor(Math.random() * (canvas.width/GRID)), y: Math.floor(Math.random() * (canvas.height/GRID - 5)) + 1};
            snake.score = 0;
            gameRunning = true;
        }

        function drawSnake() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // 体
            ctx.fillStyle = '#0f0';
            snake.body.forEach(seg => ctx.fillRect(seg.x * GRID, seg.y * GRID, GRID-2, GRID-2));
            // 頭
            ctx.fillStyle = '#fff';
            ctx.fillRect(snake.body[0].x * GRID + 2, snake.body[0].y * GRID + 2, GRID-6, GRID-6);
            // 食べ物
            ctx.fillStyle = '#f00';
            ctx.fillRect(snake.food.x * GRID + 4, snake.food.y * GRID + 4, GRID-10, GRID-10);
            // スコア
            ctx.font = 'bold 40px Arial';
            ctx.fillStyle = '#fff';
            ctx.fillText(`スコア: ${snake.score}`, 30, 60);
        }

        let lastDir = {x:1,y:0};
        function changeDir(d) {
            if (d.x === -lastDir.x || d.y === -lastDir.y) return;
            snake.dir = d;
            lastDir = d;
        }

        window.addEventListener('keydown', e => {
            if (currentGame !== 'snake') return;
            if (e.key === 'ArrowUp' || e.key === 'w') changeDir({x:0,y:-1});
            if (e.key === 'ArrowDown' || e.key === 's') changeDir({x:0,y:1});
            if (e.key === 'ArrowLeft' || e.key === 'a') changeDir({x:-1,y:0});
            if (e.key === 'ArrowRight' || e.key === 'd') changeDir({x:1,y:0});
        });

        function updateSnake() {
            const head = {x: snake.body[0].x + snake.dir.x, y: snake.body[0].y + snake.dir.y};
            if (head.x < 0 || head.x >= canvas.width/GRID || head.y < 0 || head.y >= canvas.height/GRID ||
                snake.body.some(s => s.x === head.x && s.y === head.y)) {
                gameRunning = false;
                return;
            }
            snake.body.unshift(head);
            if (head.x === snake.food.x && head.y === snake.food.y) {
                snake.score += 10;
                snake.food = {x: Math.floor(Math.random() * (canvas.width/GRID)), y: Math.floor(Math.random() * (canvas.height/GRID - 5)) + 1};
            } else {
                snake.body.pop();
            }
        }

        // === 共通 ===
        function initGame() {
            if (currentGame === 'bounce') initBounce();
            if (currentGame === 'snake') initSnake();
        }

        restartBtn.onclick = () => {
            initGame();
            lastTime = Date.now();
            restartBtn.style.display = 'none';
        };

        function drawOver() {
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.font = 'bold 50px Arial';
            ctx.fillText('ゲームオーバー', canvas.width/2, canvas.height/2);
            ctx.font = '40px Arial';
            const sc = currentGame === 'bounce' ? bounce.score : snake.score;
            ctx.fillText(`スコア: ${sc}`, canvas.width/2, canvas.height/2 + 60);
            restartBtn.style.display = 'block';
        }

        function gameLoop() {
            if (currentGame === 'bounce') {
                updatePaddle();
                if (gameRunning) updateBounce();
                drawBounce();
            } else if (currentGame === 'snake') {
                const now = Date.now();
                if (now - lastTime > BASE / (speedLevel / 5)) {
                    if (gameRunning) updateSnake();
                    lastTime = now;
                }
                drawSnake();
            }

            if (!gameRunning) drawOver();

            requestAnimationFrame(gameLoop);
        }

    </script>
</body>
</html>
